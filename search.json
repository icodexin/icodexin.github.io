[{"title":"在 Hexo 中渲染 LaTeX 公式","path":"//post/hexo-latex-render/","content":"一直用LaTeX写公式很久了，但发现在Hexo中渲染存在问题。推荐使用Mathjax插件解决。 方案一这个方案可以解决LaTeX特殊字符（如*，{，}，\\\\）和Markdown语法的冲突。但是我在用的时候，发现它和表格之间存在冲突。就是在有序列表中使用表格时，不能正确渲染表格。 更改渲染引擎将hexo-renderer-marked更改为hexo-renderer-kramed 安装Mathjax插件 解决语义冲突更改node_modules/kramed/lib/rules/inline.js的第11行，取消对\\,{,}的转义 blog/node_modules/kramed/lib/rules/inline.js12// escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/ 第20行的em变量也要做相应的修改 12// em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/ 开启Mathjax在博客根目录的_config.yml添加如下配置： blog/_config.yml1234# MathJax Supportmathjax: enable: true per_page: true 在需要的文章的Front-matter区打开mathjax开关： blog/source/_posts/xxx.md123---mathjax: true--- 方案二上面方案会造成有序列表中表格解析异常，后来我经过搜索，发现hexo-filter-mathjax这个插件可以解决。 但是，这个方案不能解决语义冲突的问题，所以这个时候要对LaTeX公式进行转义。 比如对于公式：其正常的写法是： 正常写法123456\\left\\{\\begin{array}{l}\tv\\gets v^\\prime = \\mu v-\\eta abla C\\\\\tw\\gets w^\\prime = w + v^\\prime\\end{array} \\right. 使用hexo-filter-mathjax需要对\\进行转义： 转义后的写法123456\\left\\\\{\\begin{array}{l}\tv\\gets v^\\prime = \\mu v-\\eta abla C\\\\\\\\\tw\\gets w^\\prime = w + v^\\prime\\end{array} \\right. 推荐一个在线工具，输入LaTeX公式后可以进行转义。 在线LaTeX公式编辑器https://latexlive.com 安装MathJax插件 注意这个方案不需要更换渲染引擎。 开启MathJax在博客根目录的_config.yml添加如下配置： blog/_config.yml1234567mathjax: tags: none # 或 'ams' 或 'all' single_dollars: true # 启用单个美元符号作为内联（行内）数学公式定界符 cjk_width: 0.9 # 相对 CJK 字符宽度 normal_width: 0.6 # 相对正常（等宽）宽度 append_css: true # 将 CSS 添加到每个页面 every_page: false # 如果为 true，那么无论每篇文章的前题中的 `mathjax` 设置如何，每页都将由 mathjax 呈现 在需要的文章的Front-matter里打开mathjax开关： blog/source/_posts/xxx.md123---mathjax: true---","tags":["hexo","LaTeX"],"categories":["解决方案"]},{"title":"《数据库原理及应用》课程设计","path":"//post/course-design-of-database/","content":"需求分析现要求开发电脑仓库管理系统。电脑仓库管理系统主要针对电脑的库存信息管理，对于仓库日常发生的业务，分为两大类，即入库和出库。经过数据库的设计后，用户通过相应的模块，对仓库进行简单的基本操作，即可轻松管理仓库。经过可行性分析和初步的需求调查，确定了系统的功能边界，该系统应能完成下面的功能： 信息登记：在数据库中添加相关电脑、供货商、仓库的信息； 入库：增加电脑库存并生成入库记录； 出库：减少电脑库存并生成出库记录。 功能设计顶层设计 第0层设计 入库设计 输入：待入库的电脑名称（型号）、存储该类电脑仓库名称、入库电脑数量 输出：入库记录 操作逻辑： 根据输入信息，检查电脑型号、仓库名称是否存在，若只要有一个不存在，拒绝入库请求； 查询库存表中是否有记录，如果没有记录，那么认定为新库存信息，向库存中添加这一信息即可；如果有记录，那么将该记录的电脑数量数据项修改为入库后的数量即可。 出库设计 输入：待出库的电脑名称（型号）、存储该类电脑仓库名称、出库电脑数量 输出：出库记录 操作逻辑： 根据输入信息，检查电脑型号、仓库名称是否存在，若只要有一个不存在，拒绝出库请求； 查询库存表中是否有记录，如果没有记录，那么表示该仓库中没有存储这类电脑，拒绝出库请求；如果有记录，检测出库电脑数量是否大于库存数量，如果大于，表示库存不足，拒绝出库请求；如果有记录并且库存充足，那么将该记录的电脑数量数据项修改为出库后的数量即可。 关系模型E-R图 关系模型设计 关系名 属性及码 其他约束条件 供应商 供应商编号，供应商名称，供应商地址，供应商电话 1、 供应商名称不允许为空；2、 供应商电话不允许为空 电脑 电脑编号，电脑名称，电脑品牌，电脑单价，供货商编号 1、 电脑名称不允许为空；2、 电脑单价不允许为空；3、 供货商编号引用供货商中的供应商编号 仓库 仓库编号，仓库名称，仓库地址，仓库电话 1、 仓库名称不允许为空；2、 仓库电话不允许为空 库存 库存记录编号，电脑编号，仓库编号，电脑数量 1、 电脑编号引用电脑关系中的电脑编号；2、 仓库编号引用仓库关系中的仓库编号 入库记录 入库记录编号，请求入库电脑名称，仓库名称，入库数量，入库总金额，操作日期时间，是否为新型号电脑，成功入库否 1、 操作日期时间不允许为空；2、 入库否不允许为空 出库记录 出库记录编号，请求出库电脑名称，仓库名称，出库数量，操作日期时间，是否全部出库，成功出库否 1、 操作日期时间不允许为空；2、 成功出库否不允许为空 数据库表设计Supplier（供应商表） 字段名 字段含义 字段类型 是否为空 列级约束 Supplier_ID 供应商编号 varchar(7) not null primary key Supplier_Name 供应商名称 varchar(30) not null unique Supplier_Address 供应商地址 varchar(50) Supplier_Tel 供应商电话 Varchar(11) not null Computer（电脑表） 字段名 字段含义 字段类型 是否为空 列级约束 Computer_ID 电脑编号 varchar(6) not null primary key Computer_Name 电脑名称 varchar(30) not null unique Computer_Brand 电脑品牌 varchar(10) Computer_Unit_Price 电脑单价 float not null Supplier_ID 供货商编号 varchar(7) not null foreign key references Supplier (Supplier_ID) Warehouse（仓库表） 字段名 字段含义 字段类型 是否为空 列级约束 Warehouse_ID 仓库编号 varchar(6) not null primary key Warehouse_Name 仓库名称 varchar(30) not null unique Warehouse_Address 仓库地址 varchar(50) Warehouse_Tel 仓库电话 varchar(11) not null Stock（库存表） 字段名 字段含义 字段类型 是否为空 列级约束 Stock_ID 库存记录编号 varchar(6) not null Computer_ID 电脑编号 varchar(6) not null foreign key references Computer(Computer_ID) Warehouse_ID 仓库编号 varchar(6) not null foreign key references Warehouse(Warehouse_ID) Number 电脑总数 int not null 表级约束：primary key (Stock_ID, Computer_ID, Warehouse_ID) InputRecords（入库记录表） 字段名 字段含义 字段类型 是否为空 列级约束 InputRecords_ID 入库记录编号 varchar(8) not null primary key Computer_Name 请求入库电脑名称 varchar(30) not null Warehouse_Name 仓库名称 varchar(30) not null Input_Number 入库数量 int Total_Money 入库总金额 float Input_DateTime 操作日期时间 datetime not null isNewTypeComputer 是否为新型号电脑 bool isSuccess 成功入库否 bool not null OutputRecords（出库记录表） 字段名 字段含义 字段类型 是否为空 列级约束 OutputRecords_ID 出库记录编号 varchar(8) not null primary key Computer_Name 请求出库电脑名称 varchar(30) not null Warehouse_Name 仓库名称 varchar(30) not null Output_Number 出库数量 int Output_DateTime 操作日期时间 datetime not null isAllOutput 是否全部出库完 bool isSuccess 成功出库否 bool not null MySQL数据库代码实践建库、建表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273-- 数据库：WarehouseDBcreate database WarehouseDB;use WarehouseDB;-- 表：供应商create table Supplier( Supplier_ID varchar(7) primary key, -- 供应商编号 Supplier_Name varchar(30) unique not null, -- 供应商名称 Supplier_Address varchar(50), -- 供应商地址 Supplier_Tel varchar(11) not null -- 供应商电话);-- 表：电脑create table Computer( Computer_ID varchar(6) primary key, -- 电脑编号 Computer_Name varchar(30) unique not null, -- 电脑名称 Computer_Brand varchar(10), -- 电脑品牌 Computer_Unit_Price float not null, -- 电脑单价 Supplier_ID varchar(7) not null, -- 供货商编号 -- 外码：Computer.Supplier_ID 参考自 Supplier.Supplier_ID foreign key (Supplier_ID) references Supplier (Supplier_ID));-- 表：仓库create table Warehouse( Warehouse_ID varchar(6) primary key, -- 仓库编号 Warehouse_Name varchar(30) unique not null, -- 仓库名称 Warehouse_Address varchar(50), -- 仓库地址 Warehouse_Tel varchar(11) not null -- 仓库电话);-- 表：库存create table Stock( Stock_ID varchar(6), -- 库存记录编号 Computer_ID varchar(6), -- 电脑编号 Warehouse_ID varchar(6), -- 仓库编号 Number int not null, -- 电脑总数 -- 主码构成：Stock_ID, Computer_ID, Warehouse_ID primary key (Stock_ID, Computer_ID, Warehouse_ID), -- 外码：Stock.Computer_ID 参考自 Computer.Computer_ID foreign key (Computer_ID) references Computer (Computer_ID), -- 外码：Stock.Warehouse_ID 参考自 Warehouse.Warehouse_ID foreign key (Warehouse_ID) references Warehouse (Warehouse_ID));-- 表：入库记录create table InputRecords( InputRecords_ID varchar(8) primary key, -- 入库记录编号 Computer_Name varchar(30) not null, -- 请求入库电脑名称 Warehouse_Name varchar(30) not null, -- 仓库名称 Input_Number int, -- 入库数量 Total_Money float, -- 入库总金额 Input_DateTime datetime not null, -- 操作日期时间 isNewTypeComputer bool, -- 是否为新型号电脑 isSuccess bool not null -- 成功入库否);-- 表：出库记录create Table OutputRecords( OutputRecords_ID varchar(8) primary key, -- 出库记录编号 Computer_Name varchar(30) not null, -- 请求出库电脑名称 Warehouse_Name varchar(30) not null, -- 仓库名称 Output_Number int, -- 出库数量 Output_DateTime datetime not null, -- 出库日期时间 isAllOutput bool, -- 是否全部出库完 isSuccess bool not null -- 成功出库否); 编写存储过程添加供货商1234567891011121314151617-- 添加供货商create procedure AddSupplier(in Name varchar(30), in Address varchar(50), in Tel varchar(11))begin declare ID int(5) zerofill; -- 生成ID号 select max(cast(substr(Supplier_ID, 3) as signed integer)) into ID from Supplier; if ID is null then set ID = 1; else set ID = ID + 1; end if; -- 插入到Supplier表中 insert into Supplier value (concat(&#x27;Su&#x27;, ID), Name, Address, Tel);end; 添加仓库1234567891011121314151617-- 添加仓库create procedure AddWarehouse(in Name varchar(30), in Address varchar(50), in Tel varchar(11))begin declare ID int(5) zerofill; -- 生成ID号 select max(cast(substr(Warehouse_ID, 2) as signed integer)) into ID from Warehouse; if ID is null then set ID = 1; else set ID = ID + 1; end if; -- 插入到Supplier表中 insert into Warehouse value (concat(&#x27;W&#x27;, ID), Name, Address, Tel);end; 添加电脑1234567891011121314151617181920212223242526272829303132333435-- 添加电脑create procedure AddComputer(in Name varchar(30), in Brand varchar(10), in Price float, in SupplierName varchar(30))AddProcedure:begin -- 供货商ID declare SupplierID varchar(7); -- 要生成的电脑ID declare ID int(5) zerofill; -- 查询对应供货商编号 select Supplier_ID into SupplierID from Supplier where Supplier_Name = SupplierName; -- 检查供货商是否存在 if SupplierID is null then rollback; -- 回滚事务 leave AddProcedure; end if; -- 生成电脑ID select max(cast(substr(Computer_ID, 2) as signed integer)) into ID from Computer; if ID is null then set ID = 1; else set ID = ID + 1; end if; -- 插入到Computer表中 insert into Computer value (concat(&#x27;C&#x27;, ID), Name, Brand, Price, SupplierID);end AddProcedure; 入库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155-- 入库create procedure Push(in ComputerName varchar(30), in WarehouseName varchar(30), in PushNumber int)begin -- 库存中电脑编号 declare ComputerID varchar(6); -- 库存中仓库编号 declare WarehouseID varchar(6); -- 要生成的记录ID declare RecordsID int(7) zerofill; -- 当前库存数量 declare CurrentNumber int; -- 电脑单价 declare UnitPrice float; -- 入库总金额 declare TotalMoney float; PUSH: begin -- 检查参数 CheckOut: begin -- 查询对应电脑编号 select Computer_ID into ComputerID from Computer where Computer_Name = ComputerName limit 1; -- 查询对应仓库编号 select Warehouse_ID into WarehouseID from Warehouse where Warehouse_Name = WarehouseName limit 1; -- 检查电脑ID是否已存在 if ComputerID is null then set @isSuccess = false; -- 标识请求未成功 leave PUSH; end if; -- 检查仓库id是否已存在 if WarehouseID is null then set @isSuccess = false; -- 标识请求未成功 leave PUSH; end if; -- 查询当前库存数量 select Number INTO CurrentNumber from Stock where Stock.Computer_ID = ComputerID and Stock.Warehouse_ID = WarehouseID; -- 查询电脑单价 select Computer_Unit_Price into UnitPrice from Computer where Computer_Name = ComputerName; -- 计算入库总金额 set TotalMoney = UnitPrice * PushNumber; end CheckOut; -- 入库 PushProcedure: begin set @isSuccess = true; -- 标记请求成功 if CurrentNumber is null then -- 新电脑入库 begin -- 要生成的库存号 declare StockID int(5) zerofill; -- 新电脑入库标记 set @isNew = true; -- 生成库存号 select max(cast(substr(Stock_ID, 2) as signed integer)) into StockID from Stock; if StockID is null then set StockID = 1; else set StockID = StockID + 1; end if; -- 库存表更新 insert into Stock value (concat(&#x27;S&#x27;, StockID), ComputerID, WarehouseID, PushNumber); end; else begin -- 查询该型号电脑的库存ID select Stock_ID into @CurrentID from Stock where Stock.Computer_ID = ComputerID and Stock.Warehouse_ID = WarehouseID; -- 库存表更新 update Stock set Number = Number + PushNumber where Stock_ID = @CurrentID; -- 标记非新电脑入库 set @isNew = false; end; end if; end PushProcedure; end PUSH; ReturnInfo: begin -- 生成入库记录ID select max(cast(substr(InputRecords_ID, 2) as signed integer)) into RecordsID from InputRecords; if RecordsID is null then set RecordsID = 1; else set RecordsID = RecordsID + 1; end if; -- 根据@isSuccess生成相应入库记录 if @isSuccess = true then -- 插入到记录表 insert into InputRecords values (concat(&#x27;I&#x27;, RecordsID), ComputerName, WarehouseName, PushNumber, TotalMoney, sysdate(), @isNew, true); -- 展示本次请求信息 select concat(&#x27;I&#x27;, RecordsID) 记录编号, ComputerName 请求入库电脑, WarehouseName 仓库, PushNumber 入库数量, TotalMoney 总金额, sysdate() 操作日期时间, if(@isNew = true, &#x27;是&#x27;, &#x27;否&#x27;) 是否为新型号电脑, &#x27;是&#x27; 是否成功入库; else -- 插入到记录表 insert into InputRecords values (concat(&#x27;I&#x27;, RecordsID), ComputerName, WarehouseName, PushNumber, null, sysdate(), null, false); -- 展示本次请求信息 select concat(&#x27;I&#x27;, RecordsID) 记录编号, ComputerName 请求入库电脑, WarehouseName 仓库, PushNumber 入库数量, sysdate() 操作日期时间, &#x27;否&#x27; 是否成功入库; end if; end ReturnInfo; -- 提交事务 commit;end; 出库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107-- 出库create procedure Pop(in ComputerName varchar(30), in WarehouseName varchar(30), in PopNumber int)begin -- 未出库前库存数量 declare NumberInStock int; -- 库存中电脑编号 declare ComputerID varchar(6); -- 库存中仓库编号 declare WarehouseID varchar(6); -- 要生成的记录ID declare RecordsID int(7) zerofill; POP: begin -- 查询对应电脑编号 select Computer_ID into ComputerID from Computer where Computer_Name = ComputerName limit 1; -- 查询对应仓库编号 select Warehouse_ID into WarehouseID from Warehouse where Warehouse_Name = WarehouseName limit 1; -- 查询库存中的电脑数量 select Number into NumberInStock from Stock where Computer_ID = ComputerID and Warehouse_ID = WarehouseID limit 1; -- 库存中没有这种型号的电脑 if (NumberInStock is null) then set @isSuccess = false; -- 标记请求失败 leave POP; end if; -- 库存中电脑数量小于待出库电脑数量 if (NumberInStock &lt; PopNumber) then set @isSuccess = false; -- 标记请求失败 leave POP; end if; -- 库存中电脑数量等于待出库电脑数量 if (NumberInStock = PopNumber) then set @isAllOutput = true; -- 全部出库完 end if; -- 库存中电脑数量大于待出库电脑数量 if (NumberInStock &gt; PopNumber) then set @isAllOutput = false; end if; -- 修改Stock表 update Stock set Number = Number - PopNumber where Computer_ID = ComputerID and Warehouse_ID = WarehouseID; set @isSuccess = true; -- 标记请求成功 end POP; -- 生成出库记录ID select max(cast(substr(OutputRecords_ID, 2) as signed integer)) into RecordsID from OutputRecords; if RecordsID is null then set RecordsID = 1; else set RecordsID = RecordsID + 1; end if; -- 根据@isSuccess生成相应入库记录 if @isSuccess = true then -- 生成出库记录 insert into OutputRecords values (concat(&#x27;O&#x27;, RecordsID), ComputerName, WarehouseName, PopNumber, sysdate(), @isAllOutput, true); -- 展示本次请求信息 select concat(&#x27;O&#x27;, RecordsID) 记录编号, ComputerName 请求出库电脑, WarehouseName 仓库, PopNumber 出库数量, sysdate() 操作日期时间, if(@isAllOutput = true, &#x27;是&#x27;, &#x27;否&#x27;) 是否全部出库完, &#x27;是&#x27; 是否成功出库; else -- 生成出库记录 insert into OutputRecords values (concat(&#x27;O&#x27;, RecordsID), ComputerName, WarehouseName, PopNumber, sysdate(), null, false); -- 展示本次请求信息 select concat(&#x27;O&#x27;, RecordsID) 记录编号, ComputerName 请求出库电脑, WarehouseName 仓库, PopNumber 出库数量, sysdate() 操作日期时间, &#x27;否&#x27; 是否成功出库; end if; -- 提交事务 commit;end; 查询仓库123456789101112131415161718-- 查询仓库create procedure ShowStock()begin select Stock_ID 编号, Computer_Brand 品牌, Computer_Name 型号, Computer_Unit_Price 单价, Number 数量, Warehouse_Name 仓库地址, Supplier_Name 供货商 from Stock, Computer, Warehouse, Supplier where Stock.Computer_ID = Computer.Computer_ID and Stock.Warehouse_ID = Warehouse.Warehouse_ID and Computer.Supplier_ID = Supplier.Supplier_ID;end; SQL语句执行登记相关信息123456789101112131415161718-- 添加供货商call AddSupplier(&#x27;供货商一&#x27;, &#x27;供货商一地址&#x27;, &#x27;02710000001&#x27;);call AddSupplier(&#x27;供货商二&#x27;, &#x27;供货商二地址&#x27;, &#x27;02710000002&#x27;);call AddSupplier(&#x27;供货商三&#x27;, &#x27;供货商三地址&#x27;, &#x27;02710000003&#x27;);-- 添加仓库call AddWarehouse(&#x27;仓库一&#x27;, &#x27;仓库一地址&#x27;, &#x27;02720000001&#x27;);call AddWarehouse(&#x27;仓库二&#x27;, &#x27;仓库二地址&#x27;, &#x27;02720000002&#x27;);-- 添加电脑call AddComputer(&#x27;Lenovo-Air14&#x27;, &#x27;Lenovo&#x27;, 5999, &#x27;供货商一&#x27;);call AddComputer(&#x27;Lenovo-R7000&#x27;, &#x27;Lenovo&#x27;, 6057, &#x27;供货商一&#x27;);call AddComputer(&#x27;Lenovo-Yoga14&#x27;, &#x27;Lenovo&#x27;, 6299, &#x27;供货商一&#x27;);call AddComputer(&#x27;Lenovo-Pro14&#x27;, &#x27;Lenovo&#x27;, 6299, &#x27;供货商二&#x27;);call AddComputer(&#x27;MiBook-Pro-15.6&#x27;, &#x27;XiaoMi&#x27;, 6999, &#x27;供货商二&#x27;);call AddComputer(&#x27;Dell-G3&#x27;, &#x27;Dell&#x27;, 6999, &#x27;供货商二&#x27;);call AddComputer(&#x27;Dell-XPS13&#x27;, &#x27;Dell&#x27;, 8888, &#x27;供货商二&#x27;);call AddComputer(&#x27;MacBook-Pro-13&#x27;, &#x27;Apple&#x27;, 9199, &#x27;供货商三&#x27;);call AddComputer(&#x27;MacBook-Pro-16&#x27;, &#x27;Apple&#x27;, 17399, &#x27;供货商三&#x27;);call AddComputer(&#x27;Surface-Pro-7&#x27;, &#x27;Microsoft&#x27;, 5788, &#x27;供货商三&#x27;); 入库12345call Push(&#x27;MacBook-Pro-16&#x27;, &#x27;仓库一&#x27;, 10);call Push(&#x27;MacBook-Pro-16&#x27;, &#x27;仓库一&#x27;, 1);call Push(&#x27;Dell-G3&#x27;, &#x27;仓库一&#x27;, 100);call Push(&#x27;Lenovo-Pro14&#x27;, &#x27;仓库二&#x27;, 45);call Push(&#x27;Lenovo&#x27;, &#x27;仓库二&#x27;, 20); -- 这个是拒绝入库的示例 出库1234call Pop(&#x27;Lenovo-Pro14&#x27;, &#x27;仓库二&#x27;, 30);call Pop(&#x27;MacBook-Pro-16&#x27;, &#x27;仓库一&#x27;, 1);call Pop(&#x27;Lenovo-Pro14&#x27;, &#x27;仓库二&#x27;, 15);call Pop(&#x27;Lenovo-Pro14&#x27;, &#x27;仓库二&#x27;, 1000); -- 这个是拒绝出库的示例 查询结果展示查询供货商表12345select Supplier_ID 编号, Supplier_Name 名称, Supplier_Address 地址, Supplier_Tel 电话from Supplier; 结果展示： 查询仓库表12345select Warehouse_ID 编号, Warehouse_Name 名称, Warehouse_Address 地址, Warehouse_Tel 电话from Warehouse; 结果展示： 查询电脑表123456789select Computer_ID 编号, Computer_Name 型号, Computer_Brand 品牌, Computer_Unit_Price 价格, Supplier_Name 供货商from Computer, Supplierwhere Supplier.Supplier_ID = Computer.Supplier_IDorder by Computer_ID ASC; 结果展示： 查询库存1call ShowStock; 结果展示： 查询入库记录123456789101112select InputRecords_ID 序号, Computer_Name 请求入库电脑, Warehouse_Name 仓库, Input_Number 出库数量, Input_DateTime 操作时间, case isNewTypeComputer when 1 then &#x27;是&#x27; when 0 then &#x27;否&#x27; when null then null end 是否为新型号电脑, if(isSuccess = 1, &#x27;是&#x27;, &#x27;否&#x27;) 成功入库否from InputRecords; 结果展示： 查询出库记录123456789101112select OutputRecords_ID 序号, Computer_Name 请求出库电脑, Warehouse_Name 仓库, Output_Number 出库数量, Output_DateTime 操作时间, case isAllOutput when 1 then &#x27;是&#x27; when 0 then &#x27;否&#x27; when null then null end 是否全部出库完, if(isSuccess = 1, &#x27;是&#x27;, &#x27;否&#x27;) 成功出库否from OutputRecords; 结果展示： 总结通过本次考查报告，从需求分析、概念结构设计、逻辑结构设计到数据库表实施，掌握了设计数据库的有关步骤。通过前期准备，掌握了数据库的理论、E-R图的构建。本次使用了MySQL数据库将理论转换为实践，初步掌握了MySQL建库、建表的语句。并编写了存储过程语句，使得数据库操作简便化。在编写SQL语句时，查阅了许多资料，增强了动手能力。本次数据的设计仍有不足，如没有考虑到数据库的多用户操作，应当对每个仓库设立若干管理员，只进行本仓库的管理，细分数据库操作，也符合实际情况，这是数据设计的改进方向。","tags":["MySQL","数据库"],"categories":["课程设计"]},{"title":"《数字逻辑》课程设计","path":"//post/course-design-of-digital-logic/","content":"题目一：数字电子钟设计设计任务及要求 任务用计数器设计一个电子钟，显示时、分、秒。 要求（1） 小时为 00-23 二十四进制计数器，分、秒为 00-59 六十进制计数器；（2） 用八段数码管进行显示时、分、秒。（3） 用 Logisim 画图，并进行仿真。要求能看到正确的时、分、秒信息。（4） 先用 Logisim 软件仿真测试是否正确，再提交网站（EduCoder）测评。 实验条件 Java Runtime Environment 环境 Logisim虚拟数字电路仿真平台 设计过程设计原理与思路4位递增计数器的设计数字电子钟的基本组成单元由4位递增计数器构成，在进行其他器件设计前，先要完成4位递增计数器的设计。计数是一种最简单的基本运算。计数器就是实现这种运算的逻辑电路，计数器在数字系统中主要是对脉冲的个数进行计数，以实现测量、计数和控制的功能，同时兼有分频功能。计数器在数字系统中应用广泛，如在电子计算机的控制器中对指令地址进行计数，以便顺序取出下一条指令，等等。这里设计了一个带有同步置数、异步清零功能的4位同步递增计数器。引脚说明： 信号 输入输出 位宽 说明 Clock 输入 1位 时钟脉冲，上升沿有效 Reset 输入 1位 异步清零端：Reset&#x3D;1时，Q&#x3D;0 Enable 输入 1位 使能端：Reset&#x3D;0时，Enable&#x3D;1递增计数、0保持 Load 输入 1位 同步置数端：Reset&#x3D;0、Load&#x3D;1、Clock上升沿时，Q&#x3D;D D 输入 4位 并行数据加载端 Q 输出 4位 状态输出端 具有并行加载功能的计数器原理如下图所示：将4位递增计数器封装后的外观： 六进制计数器的设计六进制计数器可由4位递增计数器构成，当4位递增计数器计数到6时，异步清零使Q&#x3D;0，这样就完成了六进制计数器的功能。六进制计数器是构成六十进制计数器的基础。 十进制计数器的设计十进制计数器可由4位递增计数器构成，当4位递增计数器计数到10时，异步清零使Q&#x3D;0，这样就完成了十进制计数器的功能。十进制计数器是构成六十进制计数器的基础。 六十进制计数器的设计六十进制计数器可由六进制计数器和十进制计数器构成，10进制计数器的进位输出端是六进制计数器的使能端（Enable）触发条件，每十次触发一次6进制计数器，而6进制计数器本身最大计数为6，这样就完成了六十进制计数器的功能。六十进制计数器是构成数字电子钟的基础。 24进制计数器的设计24进制计数器可由两个十进制计数器构成。可用第一个十进制表示个位，记为计数器A。第二个十进制计数器表示十位，记为计数器B。计数器A的进位输出端是计数器B的使能端（Enable）触发条件，每十次触发一次计数器B，同时，检测计数器A和B的状态输出端，当状态值为23时，使整个电路的进位输出端为1，当状态值为24时，异步清零，使计数器A和B的Q均为0。这样就完成了24进制计数器的功能。24进制计数器是构成数字电子钟的基础。 数字电子钟的设计数字电子钟由小时（0-23）、分钟（0-59）、秒（0-60）构成。秒由六十进制计数器构成，计数的条件是时钟的滴答。所以，在实际仿真的时候，可以调整时钟频率为1Hz，使其符合1秒1次的计数规则。分钟由六十进制计数器构成，计数的条件是当秒钟产生进位。小时由24进制计数器构成，计数的条件是当分钟和秒钟同时产生进位。在实际仿真中，用16进制数字显示器件（Hex Digit Display）显示上述器件产生的状态，这样就完成了数字电子钟的功能和设计。 逻辑电路图4位递增计数器：六进制计数器：十进制计数器：六十进制计数器：24进制计数器：数字电子钟： 实验测试将Clock信号，由手动点击改为时钟连续，将使能端Enable启动，然后进行测试： 题目二：路灯巡回检测器设计任务及要求 任务用 Verilog 语言设计 8 个路灯巡回检测电路。 要求 巡回检测 8 个路灯，并用 8 个 LED 灯显示好坏。路灯正常时对应的 LED 灯熄灭，路灯故障时对应的 LED 灯点亮； 能够迅速、准确地判出哪一个路灯坏，并用一个七段数码管显示出故障 灯的总数； 有启动停止开关。 自行绑定开发板的管脚，并下载到开发板上观察实际效果。 实验条件 Verilog编程和EDA设计工具：Altera Quartus Ⅱ 11.0 FPGA开发板：Altera DE2-115 设计过程设计原理和思路使用一个开关作为使能端，控制整个检测器的启动与停止。当使能端关闭时，每个路灯无论其是否为故障状态，都不点亮对应的LED灯。同时，七段数码管也不点亮。当使能端开启时，设定一个cnt作为计数器，使用always语句检测每一个路灯是否故障，如果该路灯故障，点亮对应的LED灯，并使cnt计数器（每次循环前，cnt置零）加1；如果该路灯不故障，用七段数码管hex显示cnt对应的数字。 Verilog代码123456789101112131415161718192021222324252627282930313233343536373839module street_lamp_detector(w, hex, leds); input [8:0] w; reg [3:0] cnt; integer k; output reg[0:7] leds; output reg[0:6] hex; always @(w, cnt) begin cnt=0; if(w[8] == 1) begin for(k = 0; k &lt; 8; k = k + 1) if(w[k] == 1) begin leds[k] = 1; cnt = cnt + 1; end else leds[k] = 0; case (cnt) 0: hex = 7&#x27;b0000001; 1: hex = 7&#x27;b1001111; 2: hex = 7&#x27;b0010010; 3: hex = 7&#x27;b0000110; 4: hex = 7&#x27;b1001100; 5: hex = 7&#x27;b0100100; 6: hex = 7&#x27;b0100000; 7: hex = 7&#x27;b0001111; 8: hex = 7&#x27;b0000000; default: hex = 7&#x27;b1111111; endcase end else begin hex = 7&#x27;b1111111; leds[0:7] = 0; end endendmodule 实验测试开发板引脚分配引脚绑定设置如下： 联机调试① 使能端Enable未启动（SW8为0）此时，所有器件不工作：② 使能端Enable启动（SW8为1）如下面两图所示，7端数码管HEX0可以根据正确显示：SW0-SW7的对应故障个数： 总结通过本次课程设计，掌握了有关同步时序电路的知识，了解了同步时序电路的基本设计步骤，并同通过这些知识设计出了基于时序电路的计数器，完成了数字电子钟的仿真设计。通过本次课程设计，掌握了Verilog语言的基本特征，学习了always、if、case等语句。结合Altera ED2-115开发版，通过Verilog语言进行编程，最终实现了一个路灯巡回检测器。","tags":["数字电路","FPGA"],"categories":["课程设计"]},{"title":"《数据结构》课程设计","path":"//post/course-design-of-data-structure/","content":"课程设计选题：仓库管理系统 题目与要求问题描述某电子公司仓库中有若干批次的同一种电脑，按价格、数量来存储。要求实现功能: 初始化 n 批不同价格电脑入库； 出库：销售m台价格为p的电脑； 入库：新到m台价格为p的电脑； 盘点：电脑的总台数，总金额，最高价，最低价，平均价格。 注：每个数据元素含有价格与数量；同一价格的电脑存储为一个数据元素。 系统涉及知识点仓库管理系统可以使用顺序表、有序表、单链表、有序循环链表等实现，本设计采用有序表实现。所谓有序表，是指这样的线性表，其中所有的元素以递增或递减方式有序排列。首先要指出的是，有序表是基于顺序表而延伸出来的一种数据结构，其共同点是用一组地址连续的存储单元依次存储线性表的数据元素。其次，是有序表的独特之处，它其中的数据元素按照一定的顺序有序排列。仓库管理系统适合采用有序表，原因是可以按照商品的价格或数量进行有序排列，方便用户比对价格、数量。 功能要求 初始化仓库：初始化n批不同型号的电脑入库； 入库：新到m台价格为p的电脑； 出库：销售m台价格为p的电脑； 盘点仓库：列出仓库的关键数据：电脑的总台数、总金额、最高价、平均价格等； 按照有序表的特点以及所使用的编程语言（C++）的特性，本程序还提供了以下功能： 查询某一型号的电脑的价格、数量； 重新对仓库数据按照一定规则排序； 导出仓库数据到外部文件； 从外部文件导入数据，以初始化仓库。 功能设计数据结构定义一、基本数据元素：电脑 12345typedef struct computer { char type[50]; // 型号 double price; // 价格 int number; // 数量} Computer, ElemType; 基本数据元素电脑（Computer/ElemType）采用结构体表示，用于存储某一类电脑的信息：型号（type[50]）、价格（price）、库存数量（number）。二、数据结构：有序表 1234567typedef struct { ElemType *elem; // 基地址 int length; // 当前有效数据的个数 int listsize; // 当前存储容量(单位是sizeof(ElemType)) bool isInit{false}; // 顺序表是否已经初始化 int sortWay{1}; // 顺序表的排序方式} SqList; 数据结构有序表（SqList）由以下几个部分组成： 数组指针elem指示有序表的基地址； length指示有序表的当前有效数据个数（长度）； listsize指示有序表当前分配的存储空间大小，一旦因插入数据元素（Computer）而空间不足时，可进行再分配； isInit指示有序表是否已经初始化（即是否有一个确定的基地址）； sortWay指示有序表的排序方式，按照值的不同，对应的有序表排序方式也不同。本程序具体设计了以下四种排序方式：1-按照价格升序、2-按照价格降序、3-按照数量升序、4-按照数量降序。 整体的数据结构如下图所示： 模块图入库入库有两种方式，一是在仓库中已有和待入库电脑型号相同的数据，此时，检查给出的价格是否与仓库中一致，若一致，同意用户的入库操作。然后只需更改仓库中此种电脑型号的数量。示意图如下： 第二种方式，入库一种新型号的电脑，则应该按照有序表的排序方式（sortWay）在正确位置插入元素。示意图如下： 出库可以出库的前提是，在仓库中有待出库型号的电脑且仓库中的库存数量大于等于待出库数量。第一类情况，待出库电脑的数量在库存中充足（即库存数量大于待出库数量），此时只需更改相应的数据元素。示意图如下：第二类情况，此种型号的电脑恰好全部出库完，则需要删除相应的数据元素。示意图如下： 功能代码初始化动态顺序表有序表的数据结构是基于顺序表实现的，所以在进行一切操作前，应当初始化一个空的动态顺序表。代码如下： 123456789Status InitSqList(SqList &amp;L, int n) { auto listsize{((n / 10) + 1) * 10}; // 确定顺序表初始内存占用空间 L.elem = new ElemType[listsize]; // 分配基地址、顺序表内存 if (!L.elem) // 内存不足 return OVERFLOW; L.length = 0; // 此时顺序表还没有元素，L.length为0 L.listsize = listsize; return OK;} 有序表初始分配的内存空间（listsize）并没有简单采用一个常数大小（如10个ElemType字节），这样不用限制用户输入的电脑类型最大个数，对用户友好。具体是通过给定的n，计算表达式((n/10)+1)*10，使得初始分配的内存为10的整数倍大小的ElemType字节，比如n为12，表达式((n/10)+1)*10则为20。 需要注意的是，初始化动态顺序表时，还暂无数据元素，L.length应为0。 创建（初始化）仓库创建仓库的前提是，已经初始化过一个空的动态顺序表，这个检测可以在主函数中完成。创建有序表式的仓库步骤： 输入n个数据元素，存储到顺序表中； 对已创建的顺序表按照有序表的排序方式（L.sortWay）进行快速排序。 更新有序表的相应参数（length、isInit、sortWay）代码如下： 12345678910111213141516171819202122232425262728293031void CreateWarehouse(SqList &amp;L, int n, int sort_way) { cout &lt;&lt; \"请输入这\" &lt;&lt; n &lt;&lt; \"种电脑各自的型号、单价、总数:(以空格分隔)\" &lt;&lt; endl; // 输入n个数据元素 for (int i = 0; i &lt; n; i++) cin &gt;&gt; L.elem[i].type &gt;&gt; L.elem[i].price &gt;&gt; L.elem[i].number; // 按照sort_way对刚创建的顺序表排序 switch (sort_way) { case 1: // 按价格升序 sort(L.elem, L.elem + n, cmp1); break; case 2: // 按价格降序 sort(L.elem, L.elem + n, cmp2); break; case 3: // 按数量升序 sort(L.elem, L.elem + n, cmp3); break; case 4: // 按数量降序 sort(L.elem, L.elem + n, cmp4); break; default: break; } // 更新L的参数 L.sortWay = sort_way; L.length = n; L.isInit = true;} 如果使用文件流创建仓库，那么代码略有不同，这部分属于C++的知识。 不同代码（输入n数据元素）如下： 123456string s;// 从文件流输入n个数据元素for (int i = 0; i &lt; n; i++) { ImportFile &gt;&gt; L.elem[i].type &gt;&gt; L.elem[i].price &gt;&gt; L.elem[i].number; getline(ImportFile, s);} 显示仓库顾名思义，就是将仓库的数据打印出来。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142// 显示仓库void PrintWarehouse(SqList L) { if (!L.length) cout &lt;&lt; \"当前仓库没有数据!\" &lt;&lt; endl; else { cout &lt;&lt; \"当前仓库数据如下:\" &lt;&lt; endl; string sort_way; switch (L.sortWay) { case 1: sort_way = \"(按照价格升序)\"; break; case 2: sort_way = \"(按照价格降序)\"; break; case 3: sort_way = \"(按照数量升序)\"; break; case 4: sort_way = \"(按照数量降序)\"; break; default: break; } cout &lt;&lt; sort_way &lt;&lt; endl; cout &lt;&lt; \"-------------------------------------------------------\" &lt;&lt; endl; cout &lt;&lt; setLeft &lt;&lt; setw(5) &lt;&lt; \"序号\" &lt;&lt; setw(20) &lt;&lt; \"型号\" &lt;&lt; setw(15) &lt;&lt; \"单价\" &lt;&lt; setw(15) &lt;&lt; \"数量\" &lt;&lt; endl; cout &lt;&lt; \"-------------------------------------------------------\" &lt;&lt; endl; for (int i = 0; i &lt; L.length; i++) cout &lt;&lt; setLeft &lt;&lt; setw(5) &lt;&lt; i + 1 &lt;&lt; setw(20) &lt;&lt; L.elem[i].type &lt;&lt; setw(15) &lt;&lt; L.elem[i].price &lt;&lt; setw(15) &lt;&lt; L.elem[i].number &lt;&lt; endl; cout &lt;&lt; \"-------------------------------------------------------\" &lt;&lt; endl; }} 入库入库要考虑两种情况，第一种情况，仓库中已经有和待入库电脑相同型号的数据元素，那么需要先比较价格是否一致（不一致拒绝用户的入库操作），然后更改仓库中此种电脑数据元素的数量值。第二种情况入库一种新型号的电脑，那么则要插入一个新的数据元素（Computer）到仓库中，并且在插入之前还要检查有序表的内存空间（listsize）是否充足，如果不足，则需要再分配有序表的内存大小，即为顺序表增加一个大小为存储LISTINCREMENT个数据元素的空间。然后，根据有序表的排序方式（L.sortWay），找到可以插入元素的地址。插入时，先将该地址及以后的地址全部后移一位，接着将当前地址写入要入库的数据元素。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Status Enter(SqList &amp;L, const Computer &amp;c) { // 寻找仓库中是否已经有和c.type同类型的电脑 for (int i = 0; i &lt; L.length; i++) { if (strcmp(c.type, L.elem[i].type) == 0) { if (c.price == L.elem[i].price) { // 检查价格价格是否与c.price相等 L.elem[i].number += c.number; return OK; } else { cout &lt;&lt; \"提示:\" &lt;&lt; endl; showInfo(L.elem[i]); return ERROR; } } } // 入库一个新类型的电脑 if (L.length &gt;= L.listsize) { // 顺序表占用空间不足 // 申请新的基地址、内存空间 auto *newbase = (ElemType *) realloc(L.elem, (L.listsize + LISTINCREMENT) * sizeof(ElemType)); if (!newbase) return OVERFLOW; L.elem = newbase; // L的基地址更改为newbase L.listsize += LISTINCREMENT; } // 按照L.sort_way对插入到顺序表中 int item{L.length}; // 确定要插入的位序 for (int i = 0; i &lt; L.length; i++) { switch (L.sortWay) { case 1: { if (c.price &lt; L.elem[i].price) { item = i; goto change_sq; } } break; case 2: { if (c.price &gt; L.elem[i].price) { item = i; goto change_sq; } } break; case 3: { if (c.number &lt; L.elem[i].number) { item = i; goto change_sq; } } break; case 4: { if (c.number &gt; L.elem[i].number) { item = i; goto change_sq; } } break; } } change_sq: ElemType *q = &amp;L.elem[item]; // 将q及q以后的元素全部后移一位 for (ElemType *p = L.elem + L.length - 1; p &gt;= q; p--) *(p + 1) = *p; // 将新元素赋给q *q = c; L.length++; return OK;} 要注意的是如果是入库一种新型号的电脑，完成操作后，应当将有序表的长度加1（L.length++）。 出库出库要考虑以下几种情况： 仓库中是否有待出库电脑的型号的相应数据元素，如果没有找到相应的电脑型号，则应当拒绝用户的出库操作； 仓库中现有库存数量是否充足，满足出库要求，如果库存数量小于待出库数量，则应当拒绝用户的出库操作； 如果库存数量大于待出库数量，那么只需更改相应数据元素的数量值； 如果库存数量恰好等于待出库数量，那么此时这种型号的电脑应从仓库中“剔除”。具体操作是，找到该数据元素的地址，将该地址及以后的地址全部前移一位。最后，更新L.length参数。 代码如下： 123456789101112131415161718192021222324252627282930313233343536Status Out(SqList &amp;L, const char *type, int num) { // 确定要出库元素的位序 int item{L.length + 1}; for (int i = 0; i &lt; L.length; i++) { if (strcmp(type, L.elem[i].type) == 0) { item = i; break; } } // 没有找到要出库元素的位序，说明在仓库中没有元素，返回错误 if (item &gt; L.length) return -1; // 确定要出库元素现有库存的数量是否可以出库 if (num &lt; L.elem[item].number) { // 正常出库 L.elem[item].number -= num; return OK; } else if (num == L.elem[item].number) { // 全部出库 cout &lt;&lt; \"提示:\" &lt;&lt; endl &lt;&lt; L.elem[item].type &lt;&lt; \"型号的电脑已全部出库!\" &lt;&lt; endl; // 将p及p以后的元素全部后移一位 for (ElemType *p = &amp;L.elem[item + 1]; p &lt;= &amp;L.elem[L.length - 1]; p++) { *(p - 1) = *p; } L.length--; return OK; } else { // 库存不足 cout &lt;&lt; \"提示:\" &lt;&lt; endl; showInfo(L.elem[item]); return ERROR; }} 查询电脑数据查询电脑数据，只需从基地址开始遍历，直到找到数据元素的型号和待查询的型号相同，那么返回电脑信息。可以定义一个item参数，初始值为L.length + 1，如果找到数据元素，则将其更新为数据元素的逻辑位序。如果遍历结束，item都未更新，说明未找到。因为数据元素的最大逻辑位序是有序表的表长（L.length），所以判断是否找到数据元素的条件是：item &gt; L.length。代码如下： 12345678910111213141516void getInfo(SqList L, const char *type) { // 确定要查找的电脑的元素位序 int item{L.length + 1}; for (int i = 0; i &lt; L.length; i++) { if (strcmp(type, L.elem[i].type) == 0) { item = i; break; } } if (item &gt; L.length) cout &lt;&lt; \"没有找到\" &lt;&lt; type &lt;&lt; \"型号的电脑\" &lt;&lt; endl; else { cout &lt;&lt; \"信息如下:\" &lt;&lt; endl; showInfo(L.elem[item]); }} 盘点仓库从基地址开始遍历，求得关键数据：总台数（numSum）、总金额（priceSum）、最高价（priceMax）、最低价（priceMin）、平均价（priceAverage）。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142void Check(SqList L) { int numSum{0}; double priceSum{0.0}, priceMax{L.elem[0].price}, priceMin{L.elem[0].price}, priceAverage{0.0}; vector&lt;char *&gt; priceMaxComputer; // 存储价格最高的电脑的类型名 vector&lt;char *&gt; priceMinComputer; // 存储价格最低的电脑的类型名 if (!L.length) { cout &lt;&lt; \"当前仓库没有数据!\" &lt;&lt; endl; } else { // 求总数、总金额、最高价、最低价 for (int i = 0; i &lt; L.length; i++) { numSum += L.elem[i].number; priceSum += L.elem[i].price * L.elem[i].number; priceMax = max(priceMax, L.elem[i].price); priceMin = min(priceMin, L.elem[i].price); } // 记录价格最高、最低的电脑类型名 for (int i = 0; i &lt; L.length; i++) { if (L.elem[i].price == priceMax) priceMaxComputer.push_back(L.elem[i].type); if (L.elem[i].price == priceMin) priceMinComputer.push_back(L.elem[i].type); } // 求平均价 priceAverage = priceSum / numSum; // 输出信息 cout &lt;&lt; \"盘点数据如下\" &lt;&lt; endl &lt;&lt; \"电脑的总台数: \" &lt;&lt; numSum &lt;&lt; endl &lt;&lt; \"电脑的总金额: \" &lt;&lt; priceSum &lt;&lt; endl &lt;&lt; \"电脑的最高价: \" &lt;&lt; priceMax &lt;&lt; endl &lt;&lt; \" + 对应的型号是: \"; for (const auto &amp;c:priceMaxComputer) cout &lt;&lt; c &lt;&lt; \"\\t\"; cout &lt;&lt; endl; cout &lt;&lt; \"电脑的最低价: \" &lt;&lt; priceMin &lt;&lt; endl &lt;&lt; \" + 对应的型号是: \"; for (const auto &amp;c:priceMinComputer) cout &lt;&lt; c &lt;&lt; \"\\t\"; cout &lt;&lt; endl; cout &lt;&lt; \"电脑的平均价格: \" &lt;&lt; priceAverage &lt;&lt; endl; }} 这里定义了两个char*向量（priceMaxComputer、priceMinComputer），用以存储价格最高的电脑的类型名、最低的电脑的类型名，因为可能若干种型号的电脑都是最高价或最低价，所以使用C++的向量数据结构比较合适。这样，可以显示出最高价、最低价相应的电脑类型名，对用户友好。 重新对仓库排序只需按照给定的排序方式，对仓库进行快速排序，然后更改L.sortWay参数为相应值。代码如下： 1234567891011121314151617181920212223cout &lt;&lt; \"请输入要重新对仓库排序的主要方式\" &lt;&lt; endl &lt;&lt; \"1. 按价格升序 2. 按价格降序\" &lt;&lt; endl &lt;&lt; \"3. 按数量升序 4. 按数量降序\" &lt;&lt; endl &lt;&lt; \"选择1-4:\";auto select = input_number(1, 4);switch (select) { case 1: sort(L.elem, L.elem + L.length, cmp1); break; case 2: sort(L.elem, L.elem + L.length, cmp2); break; case 3: sort(L.elem, L.elem + L.length, cmp3); break; case 4: sort(L.elem, L.elem + L.length, cmp4); break; default: break;}L.sortWay = select;cout &lt;&lt; \"重新排序成功!\" &lt;&lt; endl; 其中，4种排序方式的代码如下： 12345678910111213141516171819// computer排序方式：按价格升序bool cmp1(const Computer &amp;a, const Computer &amp;b) { return a.price &lt; b.price;}// computer排序方式：按价格降序bool cmp2(const Computer &amp;a, const Computer &amp;b) { return a.price &gt; b.price;}// computer排序方式：按数量升序bool cmp3(const Computer &amp;a, const Computer &amp;b) { return a.number &lt; b.number;}// computer排序方式：按数量降序bool cmp4(const Computer &amp;a, const Computer &amp;b) { return a.number &gt; b.number;} 导出仓库数据到文件原理和显示仓库大同小异，只是多了文件流的操作。代码如下： 12345678910111213141516171819202122232425262728293031323334353637void output(SqList L, const string &amp;filename) { // 定义输出文件流filename.txt ofstream OutFile(filename + \".txt\"); // 输出文件头，用于下次输入时识别文件 OutFile &lt;&lt; \"Computer Warehouse Data\" &lt;&lt; endl; if (!L.length) OutFile &lt;&lt; \"no data\" &lt;&lt; endl; else { OutFile &lt;&lt; \"The information is as follows:\" &lt;&lt; endl; switch (L.sortWay) { case 1: OutFile &lt;&lt; \"Sort Way: 1 (Ascending by price)\" &lt;&lt; endl; break; case 2: OutFile &lt;&lt; \"Sort Way: 2 (Descending by price)\" &lt;&lt; endl; break; case 3: OutFile &lt;&lt; \"Sort Way: 3 (Ascending by number)\" &lt;&lt; endl; break; case 4: OutFile &lt;&lt; \"Sort Way: 4 (Descending by number)\" &lt;&lt; endl; break; default: break; } OutFile &lt;&lt; \"Total Type: \" &lt;&lt; L.length &lt;&lt; endl; // 输出数据信息 for (int i = 0; i &lt; L.length; i++) OutFile &lt;&lt; L.elem[i].type &lt;&lt; \" \" &lt;&lt; L.elem[i].price &lt;&lt; \" \" &lt;&lt; L.elem[i].number &lt;&lt; endl; // 关闭文件 OutFile.close(); }} 调试与测试注意：本设计使用的编译器是G++ 8.1.0，在Windows平台上编译、运行成功。编译命令为：“g++ main.cpp sqlist.cpp -o main”（不含引号）。 调试分析一、创建仓库为方便用户操作，本程序可以导出仓库数据到文件，然后在下次操作时，可以用此文件做仓库的初始化。这是在考虑到程序的友好性后增加的功能。无论是手动创建还是从文件导入，方法是大同小异的。本模块时间复杂度：（快速排序）二、入库、出库、查询、盘点仓库时间复杂度均为：考虑到程序的友好性，对入库、出库、查询的拒绝操作均给出具体信息。比如，在出库时如果库存数量小于待出库数量，则先显示当前库存，然后提示库存数量不足。三、其他菜单和主函数设计中，由于经常需要检测输入数字是否在某一范围内，使得生成大量重复代码。于是，将这些代码设计成函数，增加了代码的可读性。并且考虑到，用户的误输入（非数字）会导致程序崩溃，设计了正则表达式匹配，检测用户输入。函数代码如下： 1234567891011121314151617181920// 输入from至end范围内的数字int input_number(int from, int end) { auto select{0}; string input; regex r(\"[0-9]*\"); // 正则表达式:数字0-9，可以出现多次 while (true) { cin &gt;&gt; input; bool isNumber = regex_match(input,r); if (!isNumber) // 如果input和正则表达式匹配 cout &lt;&lt; \"输入错误，请输入数字\" &lt;&lt; from &lt;&lt; \"-\" &lt;&lt; end &lt;&lt; \":\"; else { select = atoi(input.c_str()); if (select &lt; from || select &gt; end) cout &lt;&lt; \"输入错误，重新输入\" &lt;&lt; from &lt;&lt; \"-\" &lt;&lt; end &lt;&lt; \":\"; else break; } } return select;} 另外一个是，如果用户在初始化仓库的情况下，进行入库、出库等操作，亦会导致程序崩溃。所以，后来在有序表中增加了一个参数isInit，用于指示当前有序表是否已经初始化。在每次操作之前，检测是否已经初始化，这样避免了这一类型的崩溃。 用户手册启动本程序后，按照菜单的提示进行操作即可。 注意： 第一步必须先初始化仓库，否则，您无法进行其他的操作，将返回“仓库还未初始化!”。 初始化仓库时，可以选择“2.从外部文件导入”，但前提是，该外部文件要存在，且是以前程序生成的导出合法文件。否则，不存在的文件将提示“没有文件/文件无法打开”，不是合法文件将提示“文件内容不符合要求”，这会导致初始化仓库失败。所以，请检查您输入的文件名和文件内容！ 建议在入库操作之前先显示仓库，确保增加仓库中某一电脑型号的数量时，输入的价格和仓库中一致； 建议在出库操作之前先显示仓库，确保仓库中有您想要出库的电脑型号，以及其数量充足； 您可以选择菜单项“7.重新对仓库排序”，按照您喜爱的方式对仓库排序，本程序提供了四种主要排序方式：1-按照价格升序、2-按照价格降序、3-按照数量升序、4-按照数量降序 建议每次结束程序前，导出仓库数据到文件，这样可以保存仓库数据，方便下次操作。 测试过程本设计给出了一个输入文件info.txt内容如下： 12345678910111213141516Computer Warehouse DataThe information is as follows:Sort Way: 1 (Ascending by price)Total Type: 12RedmiBook-14 3299 30Dell-G5 5699 14Surface-Pro-7 5788 20Lenovo-Air14 5999 17Lenovo-R7000 6057 12Lenovo-Yoga14 6299 8Lenovo-Pro14 6299 10MiBook-Pro-15.6 6999 13Dell-G3 6999 15Dell-XPS13 8888 5MacBook-Pro-13 9199 5MacBook-Pro-16 17399 3 下面是各种操作的输出结果（截图）：1、菜单显示2、初始化仓库3、显示仓库4、入库入库Dell-G5 5699 2：入库后显示仓库：入库Huawei-MateBook-X 8999 2：入库后显示仓库：5、出库出库Huawei-MateBook-X 2:出库后显示仓库：6、查询查询Lenovo-Pro147、盘点仓库8、重新对仓库排序按数量升序对仓库排序：显示重新排序后的仓库： 总结通过本次课程设计，在数据结构课程中所学到的顺序表基础上，实现了有序表，并通过基本数据元素（Computer）和数据结构（SqList）的设计，实现了简易的仓库管理系统。在本次课程设计中，也学习到很多的C++的知识，如STL中数据结构与算法的应用（vector、sort）、文件流（fstream）。通过设计输入输出文件的功能，解决了以往繁琐的数据输入步骤。同时，也增加了程序的友好性。通过输入检测、正则表达式匹配，解决了非法输入导致程序崩溃的问题。但限于编程能力，本程序仍存在某些问题，如初始化时，没有对输入相同型号的数据做处理，这是程序的改进方向。 参考文献[1] 严蔚敏，吴伟民.数据结构（C语言版）[M]. 北京：清华大学出版社，1997.[2] 严薇敏，吴卫民.数据结构题集（C 语言版）[M].北京：清华大学出版社，1997.[3] [美]Y.Danie Liang. C++程序设计.[M].北京：机械工业出版社，2015.[4] Michael Wong，IBM XL编译器中国开发团队.深入理解C++11：C++11新特性解析与应用.[M].北京：机械工业出版社，2013. 附录源代码见Github仓库","tags":["数据结构","C++"],"categories":["课程设计"]},{"title":"2020全国大学生计算机技能应用大赛决赛C语言编程题摘录","path":"//post/2020computer-skill-competition/","content":"记录决赛两道编程题，比赛时由于时间紧张和经验不足，未有效完成。现记录并完善。 综合应用题题目2020年是特殊的一年，COVID-19 的传播给全世界都带来了极大的威胁。中国在疫情防治工作上有着突出表现，向社会、世界都做出了极大的贡献，让我们一同为祖国点赞。疫情防治工作，重在预防，各个地区都应当相互学习合适又优秀的防疫措施。如果能够依据现有的疫情数据分析出具有相似疫情情况的地区，那么对于挖掘疫情发展规律、分析疫情防控效能和落实疫情防治举措都会有积极的影响。现给出5个地区的当前疫情数据，请分析出疫情最相似的两个地区。具体要求如下: 使用C语言程序设计实现; 为每个地区的疫情情况构建结构体，该结构体包括以下属性:地区名、新增患者数、现有患者数、累积患者数、治愈患者数、死亡患者数。 相似程度算法如下: 其中，i 指的是 x 和 y 对象的第 i 维特征。sim越大，则两个对象越相似。 现有的5个地区的当前疫情数据是: 序号 地区名 新增患者数 现有患者数 累积患者数 治愈患者数 死亡患者数 1 cityA 3 3 582 573 6 2 cityB 4 3 238 234 1 3 cityC 5 3 197 191 3 4 cityD 3 2 692 683 7 5 cityE 6 2 171 163 6 要求提供数据输入功能。 要求输出部分必须有最相似的两个地区的名字。 输入输出样例： （有改编） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;typedef struct _City{\tchar name[50];\tint add;\tint exist;\tint count;\tint cure;\tint die;} City;// 定义_similarity结构体用于存最大的相似值typedef struct _similarity{\tchar name1[50];\tchar name2[50];\tdouble sim_number;} similarity;// 根据公式求相似值double sim(City x, City y){\tint sum1 = 0, sum2 = 0, sum3 = 0;\tsum1 = x.add * y.add + x.exist * y.exist + x.count * y.count + x.cure * y.cure + x.die * y.die;\tsum2 = x.add * x.add + x.exist * x.exist + x.count * x.count + x.cure * x.cure + x.die * x.die;\tsum3 = y.add * y.add + y.exist * y.exist + y.count * y.count + y.cure * y.cure + y.die * y.die;\treturn sum1 / sqrt(sum2) / sqrt(sum3);}int main(int argc, char *argv[]){\tint n;\tprintf(\"Pleas input the number of cities:\");\tscanf(\"%d\", &amp;n);\tCity city[n];\tprintf(\" Pleas input the information of %d cities: \", n); //输入各个结构体\tfor (int i = 0; i &lt; n; i++)\t{ printf(\"NO.%d city: \", i + 1); printf(\"\\tCity name:\"); scanf(\"%s\", city[i].name); printf(\"\\tNumber of new patients:\"); scanf(\"%d\", &amp;city[i].add); printf(\"\\tNumber of existing patients:\"); scanf(\"%d\", &amp;city[i].exist); printf(\"\\tCumulative number of patients:\"); scanf(\"%d\", &amp;city[i].count); printf(\"\\tNumber of patients cured:\"); scanf(\"%d\", &amp;city[i].cure); printf(\"\\tNumber of patients died:\"); scanf(\"%d\", &amp;city[i].die); printf(\" \");\t} //先将最相似定义为第一个city和第二个city\tsimilarity most_like;\tstrcpy(most_like.name1, city[0].name);\tstrcpy(most_like.name2, city[1].name);\tmost_like.sim_number = sim(city[0], city[1]);\tprintf(\"------------------------------------------------------------------- \");\tprintf(\"The results of the analysis between each two cities are as follows: \"); //分析每两个之间的相似值，并记录相似值最大的那两个\tfor (int i = 0; i &lt; n - 1; i++)\t{ for (int j = i + 1; j &lt; n; j++) { printf(\"The similarity of epidemic situation between %s and %s: %.6f \", city[i].name, city[j].name, sim(city[i], city[j])); if (most_like.sim_number &lt; sim(city[i], city[j])) { strcpy(most_like.name1, city[i].name); strcpy(most_like.name2, city[j].name); most_like.sim_number = sim(city[i], city[j]); } }\t}\tprintf(\" \");\tprintf(\"%s and %s are the most similar!\", most_like.name1, most_like.name2);\treturn 0;} 程序设计题题目实现一个矩阵左右循环移动的小程序。用户通过输入数据，程序作出相应动作。规定：函数fun1的功能是向左移动，函数fun2的功能是向右移动，当用户输入q时，结束程序。在给出代码框架中，可以决定是否使用全局变量r。 参考输入输出： 要求： 不改变已给出的代码； 补充fun1和fun2函数； 补充main()函数两个注释之间的代码：要求在此补充菜单式的控制流程，要求能够实现对上次变化后的矩阵进行循环横向转移(可设置转移方向和转移步数)； 关于方向，规定：输入1，代表向左转移；输入2，代表向右转移； 关于步数，规定：输入值为大于等于1的正整数。 代码框架： 代码框架123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#define N 4int r[4][4];void fun1(int (*a)[N], int x){ /* 控制向左移动 */}void fun2(int (*a)[N], int x){ /* 控制向右移动 */}int main(){ int t[][N]={25,33,14,28,19,42,57,48,39,53,39,34,27,40,77,61},i,j,m,p; char ch; printf(\"原始矩阵: \"); for(i=0; i&lt;N; i++) { for(j=0; j&lt;N; j++) { printf(\"%d \",t[i][j]); } printf(\" \"); } // 在下面写出菜单式控制流程代码 // 在上面写出菜单时控制流程代码 return 0;} （有改编） 代码实现我觉得思考清晰了就没什么难度，想清楚如何循环，每个循环的作用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#define N 4void fun1(int (*a)[N], int x){\tchar temp;\tfor (int i = 0; i &lt; N; i++) // 第 0 ~ N 行\t{ for (int k = 0; k &lt; x; k++) // 每一行移动 x 次 { temp = a[i][0]; for (int j = 1; j &lt; N; j++) //\t每一次的移动过程 { a[i][j - 1] = a[i][j]; } a[i][N - 1] = temp; }\t}}void fun2(int (*a)[N], int x){\tchar temp;\tfor (int i = 0; i &lt; N; i++) // 第 0 ~ N 行\t{ for (int k = 0; k &lt; x; k++) // 每一行移动 x 次 { temp = a[i][N - 1]; for (int j = N; j &gt; 0; j--) //\t每一次的移动过程 { a[i][j] = a[i][j - 1]; } a[i][0] = temp; }\t}}int main(){\tint t[][N] = {{25, 33, 14, 28}, {19, 42, 57, 48}, {39, 53, 39, 34}, {27, 40, 77, 61}}, i, j, m, p;\tchar ch;\tprintf(\"原始矩阵: \");\tfor (i = 0; i &lt; N; i++)\t{ for (j = 0; j &lt; N; j++) { printf(\"%d \", t[i][j]); } printf(\" \");\t}\tdo\t{ printf(\" 输入移动的方向[向左1,向右2]:\"); scanf(\"%d\", &amp;m); printf(\"输入移动的步数:\"); scanf(\"%d\", &amp;p); if (m == 1) fun1(t, p); else fun2(t, p); printf(\" 移动后的矩阵: \"); for (i = 0; i &lt; N; i++) { for (j = 0; j &lt; N; j++) { printf(\"%d \", t[i][j]); } printf(\" \"); } printf(\"退出请按q键，继续请按任意键后回车\"); getchar(); ch = getchar();\t} while (ch != 'q' &amp;&amp; ch != 'Q'); return 0;}","tags":["C语言","算法"],"categories":["学习笔记"]},{"title":"安装Ubuntu 20.04实战教程","path":"//post/install-ubuntu-20-04/","content":"本文仅适用于UEFI+GPT类型的PC，有关这方面的知识请自行了解。 引言为什么需要使用 Linux 系统？既已看到此文，我相信你一定有需求来使用Linux系统了。 Linux是服务器首选操作系统 稳定、高效Linux系统相对Windows系统稳定并且高效，服务器要求长时间运行不关机，显然Windows系统不适和使用在服务器上。并且Linux系统更改大多数配置都无需重启服务器即可生效，这也确保了 Linux 服务器最短的停机时间。开源Linux系统是开源的，你可以对系统进行自定义，以满足使用要求，这是Windows无法比拟的。性能良好服务器端Linux可自由配置GUI界面或者仅使用终端进行管理，保证其对硬件配置需求低。 而作为程序员的你，如果要做在服务器上进行开发，就必须要学会使用Linux！我认为，如果仅做开发，Linux系统实在太自由、舒服了！在终端里演绎出自己的世界，一行一行命令即可掌控全局！​也不再有国内生态下Windows满天飞的广告了！ 为什么选择Ubuntu？这个嘛，因为Ubuntu对新手太友好了！而且，Ubuntu对桌面系统支持特别好。同时，使用Ubuntu的人也非常多。 安装前准备已经安装好Windows10的一台PC官方推荐配置：2&nbsp;GHz&nbsp;双核处理器或更快的处理器4&nbsp;GB&nbsp;系统内存25&nbsp;GB&的可用硬盘空间本文PC平台：项目配置品牌型号Lenovo Xiaoxin Pro-13 IML 2019CPUIntel Core i7-10710URAM16 GBSSD512GBGPUNVIDIA Geforce MX250已安装Win10版本Windows 10 Pro 1909 18363.900本文安装教程仅在此平台测试过，其他PC平台请自行参考Ubuntu 20.04 镜像文件从Ubuntu官网下载Ubuntu 20.04 LTS 镜像文件。点击 download 按钮下载Ubuntu 20.04 LTS 镜像文件点击下载按钮后可能会出现捐助页面，你可以根据个人情况进行捐助。如果你觉得下载速度慢，你可以使用某些下载器（如迅雷、Motrix）进行下载。一个空间大于4GB的U盘请在安装前，确保U盘内所有内容都已备份！U盘将用于制作Ubuntu安装盘。另外，推荐使用USB3.0以上的U盘（PC也要有USB3.0端口），安装时间更快。一款USB启动盘制作软件常见的工具软件是UltralSO，不过此处我推荐使用Rufus，使用它安装系统更为简洁、明了。并且Ubuntu官网也推荐使用Rufus进行安装。点击 Rufus 3.11 进行下载检查电脑BIOS模式使用Win+R打开运行窗口，输入msinfo32后回车，出现以下界面，可查看BIOS模式：BIOS模式 可见，本文BIOS模式为UEFI，如果你显示为“传统”字样，那么本教程可能不适用你的电脑。BIOS模式有传统的MBR模式和新式UEFI模式，这将对安装双系统的方法产生直接影响。目前来看，大部分电脑都属于新式UEFI模式，不过也存在一些老机子仍然属于传统MBR模式。本教程只介绍新式UEFI模式下的双系统安装方法，如果你的电脑属于传统MBR模式，强烈建议你重装Windows系统来更新BIOS模式到UEFI。 STEP1 制作U盘启动安装盘打开Rufus软件，选择U盘设备此时请确保设备下拉框选中的是你的U盘加载引导镜像点击选择按钮，这将打开一个文件选择窗口，请选择之前下载好的Ubuntu 20.04 LTS 镜像（本教程下载后的镜像名为Ubuntu-20.04-desktop-amd64.iso）选择分区类型前文已经提到，本机BIOS采用的是UEFI，所以将分区类型选择为GPT模式。选择分区类型写入镜像在进行此操作前，请确保U盘文件已备份。点击开始按钮，将进行写入操作。同时，可能会提示“检测到ISOHybrid镜像”，请选择默认选项，并点击OK。检测到ISOHybrid镜像之后，还会弹出警告窗口，请确保已备份U盘文件，然后点击确定，这将开始操作。使用USB3.0的U盘，大约在3分钟后完成写入操作。完成后，可以关闭软件。 STEP2 分配用于Ubuntu的空间大小启动磁盘管理右键左下角Windows图标，选择“磁盘管理”选项。分配空间在PC磁盘（非U盘）末尾（也就是最后一个盘）分配一个合适大小的空间，用于Ubuntu的使用。（如果你的PC是双硬盘，本文可能不适用）右键最后一个盘(此处为E盘)，点击压缩卷，以压缩出Ubuntu的空间。输入压缩空间量，注意单位是MB，此处我选择了80GB(即80*1024=81920MB)，然后点击压缩。 最终，盘末压缩出了80GB未分配的空间，这将用于Ubuntu。现在，准备工作已经完成了一大半，请关闭计算机，进入下一步骤 STEP3 安装前的BIOS设置进入BIOS设置界面，具体品牌有具体的方法，请自行查找。(本机为开机按F2键) 以下BIOS界面所示为联想小新PRO 13 英特尔版。 设置UEFI固件选项开机按F2键，进入BIOS设置界面，点击Boot Setup 切换到Security选项卡，将Secure Boot值改为Disabled 此步骤旨在关闭安全启动。有关安装Linux系统和关闭安全启动的原因请自行了解。 退出BIOS设置界面，保存设置，并关机 STEP4 安装Ubuntu 20.02 LTS1. 插入U盘，进入U盘启动界面开机按F2键，进入启动项选择界面，点击Boot Menu 选择U盘启动项，例如这里：Linpus lite 在左上角，选择Ubuntu项，回车 等待数秒后，即可开始安装 2. 开始安装欢迎页键盘布局更新和其他软件根据需要选择安装 3. 为Ubuntu进行合理系统分区安装类型务请必选择其他选项，否则Windows系统可能将不复存在 接下来，将进行分区操作，请谨慎小心，一旦出错，后果可能出乎意料！ 有关Linux系统的目录结构与Windows的区别，请自行了解相关知识。 为Ubuntu分区有很多种方式，这里只介绍我操作的。 我的分区方案是： 挂载点 分区用于 分区类型 分区位置 大小 EFI系统分区 逻辑分区 空间起始位置 128MB - 512MB，推荐直接512MB Swap交换空间 逻辑分区 空间起始位置 视具体情况而定，见下文 &#x2F; Ext4日志文件系统 主分区 空间起始位置 可分配空间的30% &#x2F;home Ext4日志文件系统 逻辑分区 空间起始位置 剩余未分配空间 下面开始具体操作(每次操作都对上图所示橙色的空闲未分配区域）： 请一定按照顺序进行。 1. EFI系统分区EFI，全称“Extensible Firmware Interface”，即可扩展固件接口，用于操作系统启动前，完成硬件初始化，并引导进入操作系统。现在，绝大多数个人PC都使用EFI升级版本——UEFI。点击左下角“+”号，弹出创建分区界面 将大小改为512MB(推荐值)，分区类型改为逻辑分区，分区位置设置为空间起始位置，用于选择EFI系统分区。 点击OK后，请记下此时创建好的efi分区所在的设备号，如本次安装在&#x2F;dev&#x2F;nvme0n1p7 (不是Windows所在的efi分区，请看清楚) 2. Swap交换分区Swap分区在系统的物理内存不够用的时候，把硬盘内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。通俗来讲，Swap空间相当于Windows中的虚拟内存。 分配Swap分区大小视情况而定： RAM 物理内存 推荐 Swap 分区大小 需要休眠功能下建议的交换空间大小 ≤ 2GB 2倍于RAM大小 3倍于RAM大小 &gt; 2GB 和RAM相同 2倍于RAM大小 &gt; 8GB - 64GB 至少4GB 1.5倍于RAM大小 &gt; 64GB 至少4GB 不建议休眠 对本机(机带RAM 16GB)以及分配给Ubuntu的大小(80GB)，综合考虑，Swap分区设置为8GB(8192MB)。 3. 根目录 (&#x2F;)Linux的文件系统是采用级层式的树状目录结构，在此结构中最上层是根目录“&#x2F;”，然后在此目录下再创建其它的目录。 在Linux世界里，一切接文件，下图可清晰理解:根目录设置为可分配空间(此处为80GB)的30%，即大约25GB(25600MB)。 4. 家目录 (&#x2F;home)存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是&#x2F;home&#x2F;user，可以用~表示 应此分区存放内容较多，应将其设置尽可能大，而之前已经分配完该分配的空间了，这里只需将剩余的空间全部给 &#x2F;home 分区即可，这就是为什么 &#x2F;home 分区放在最后设置。 4. 执行安装注意：分区结束后请勿立即开始安装！ 请确保安装启动引导器的设备为设置EFI系统分区时的设备号！(&#x2F;dev&#x2F;nvme0n1p7) 现在，一切就绪，点击现在安装(I)，如遇提示，请点击继续后，执行安装 执行系列操作后，重新启动PC STEP5 进入Ubuntu系统重启后，提示移除安装介质，请将U盘拔出后，键入回车若没有手动选择启动项，几秒钟后将自动进入Ubuntu现在，你可以开始体验Ubuntu 20.04了！ 感谢你阅读到此，希望本文对你有所帮助，如有问题，请在主页里用邮件方式联系我！","tags":["Ubuntu","Linux","操作系统"],"categories":["解决方案","Linux"]},{"path":"/friends/index.html","content":"人生没有白走的路，每一步都算数！计算机科学与技术专业本科在读，目前主要研究人工智能与机器学习，还在探索适合自己的方向。关于动态友链 小编正在努力编写中……"},{"path":"/about/index.html","content":"人生没有白走的路，每一步都算数！计算机科学与技术专业本科在读，目前主要研究人工智能与机器学习，还在探索适合自己的方向。关于动态友链 技术栈 😊 编程语言：C, C++, Python 😂 研究方向：AI, Machine Learning, Deep Learning 😢 其实是啥都不会的废物～ 联系我下面列举了所有的联系方式，你可以选择你喜欢的方式联系我或找我玩。 Email: &#121;&#x61;&#110;&#103;&#x78;&#105;&#110;&#x40;&#x63;&#x6f;&#x64;&#x65;&#120;&#x69;&#x6e;&#46;&#99;&#110; Github: icodexin 网易云音乐: 鑫淽汀兰 CSDN: 爱编程的小芯 Bilibili: 爱编程的小芯"},{"path":"/privacy/index.html","content":"CodeXin 网站隐私政策（本页面待完善）更新日期：2023年1月1日当前隐私政策尚未完善。本站点使用了 Waline 评论，我们可能会收集您的IP地址、邮箱等信息。"},{"path":"/timeline/index.html","content":"人生没有白走的路，每一步都算数！计算机科学与技术专业本科在读，目前主要研究人工智能与机器学习，还在探索适合自己的方向。关于动态友链"},{"title":"项目简介","path":"/wiki/FER/index.html","content":"面部情绪识别是指识别传达恐惧、快乐和厌恶等基本情绪的表情。它在人机交互中起着重要作用，可应用于数字广告、在线游戏、客户反馈评估和医疗保健等方面。随着计算机视觉技术的进步，在受控条件和一致环境下拍摄的图像中能够实现较高的表情识别准确率，从而使这一技术得到运用。在自然条件下，由于类内变异较大和类间变异较小，例如面部姿势的变化和表情之间的细微差异，表情识别技术面临挑战。 计算机视觉技术的发展一直致力于提高此类问题的分类精度。在图像分类中，卷积神经网络（CNN）由于其计算效率和特征提取能力而显示出巨大的潜力。它们是FER最广泛使用的深度模型。一个包含复杂自然环境条件的具有挑战性的典型数据集是FER2013。它在2013年的国际机器学习会议（ICML）上被引入，并成为比较情感识别模型性能的基准。该数据集的绩效因子估计为65.5%。基于此，我们使用FER2013数据集作为我们的研究对象。 在本次项目实践中，我们的目标是利用CNN训练FER2013数据集，并实现实时的表情识别系统。"},{"title":"系统总结","path":"/wiki/FER/system-conclusion.html","content":"本系统实现了一种基于卷积神经网络的人脸表情识别模型，采用VGGNet神经网络，使用基于Nesterov momentum的SGD方法训练神经网络，并使用学习速率监测器减轻过拟合现象。最终，我们使用训练好的网络，构建出了可以实时识别人脸表情的一个系统。 本系统的识别精准度能够达到67%左右，尚有很大的提升空间，可改进的方向有： 由于Disgust的样本数量较少，可以考虑使用额外的训练数据或者进一步的数据增强； 尝试采用其他方法优化我们的网络，如Adagrad、AdaDelta、Adam； 考虑结合其他技术，如PCA、SVM等。 通过本次项目实践，更好地掌握了有关机器视觉方面的理论知识，并与卷积神经网络结合，同时，增强了我们的实战能力。"},{"title":"系统实现","path":"/wiki/FER/system-realize.html","content":"实验环境本地环境对于网络的构建，我们使用本地环境先行验证。本地环境的版本参数如下表所示。 版本 Python 3.7.2 Tensorflow 2.6.2 Keras 2.6.0 OpenCV 3.4.2 使用GPU训练我们使用Kaggle提供的在线环境训练我们的神经网络，配置有GPU模块。 然后将训练完的模型，再适配至本地环境，进行真实的人脸表情识别预测。 数据集概览FER2013数据集共有35887个样本，如下面的输出所示。 123data = pd.read_csv(&#x27;../input/fer2013/fer2013.csv&#x27;)# 查看数据集形状data.shape Output(35887, 3) 我们使用的FER2013数据集，以CSV格式呈现，如下图所示。 数据集概览 第0列是表情对应的数字类别，从0～1分别对应着表情：Angry（生气）、Disgust（厌恶）、Fear（害怕）、Happy（高兴）、Sad（生气）、Surprise（惊讶）、Neutral（中立）。 第二列是图像的像素数据，以行向量的形式呈现，使用空格分隔。像素值介于[0,255]之间。 第三列是该样本的用途，有Training、PublicTest、PrivateTest。 123#查看数据集的分类情况#80% 训练, 10% 验证 and 10% 测试data.Usage.value_counts() 从输出结果可知，训练数据有80%的占比，测试数据和验证数据各占10%。 OutputTraining 28709PublicTest 3589PrivateTest 3589Name: Usage, dtype: int64 样本概览查看表情分类数据，如下图所示。 1234567891011121314151617#查看表情分类数据emotion_map = &#123;0: &#x27;Angry&#x27;, 1: &#x27;Disgust&#x27;, 2: &#x27;Fear&#x27;, 3: &#x27;Happy&#x27;, 4: &#x27;Sad&#x27;, 5: &#x27;Surprise&#x27;, 6: &#x27;Neutral&#x27;&#125;emotion_counts = data[&#x27;emotion&#x27;].value_counts().sort_index().reset_index()emotion_counts.columns = [&#x27;emotion&#x27;, &#x27;number&#x27;]emotion_counts[&#x27;emotion&#x27;] = emotion_counts[&#x27;emotion&#x27;].map(emotion_map)emotion_counts# %%# 绘制类别分布条形图%matplotlib inline%config InlineBackend.figure_format = &#x27;svg&#x27;plt.figure(figsize=(6, 4))sns.barplot(x=emotion_counts.emotion, y=emotion_counts.number)plt.title(&#x27;Class distribution&#x27;)plt.ylabel(&#x27;Number&#x27;, fontsize=12)plt.xlabel(&#x27;Emotions&#x27;, fontsize=12)plt.show() 统计表 条形图 从上面的图我们可以知道，Disgust类的样本数量比较少，这是一个分布不太均匀的数据集。 图片样本示例 上图所示的是一些样本的示例图片，其生成代码如下： 123456789101112131415161718192021def row2image_label(row): pixels, emotion = row[&#x27;pixels&#x27;], emotion_map[row[&#x27;emotion&#x27;]] img = np.array(pixels.split()) img = img.reshape(48, 48) image = np.zeros((48, 48, 3)) image[:, :, 0] = img image[:, :, 1] = img image[:, :, 2] = img return image.astype(np.uint8), emotion%matplotlib inline%config InlineBackend.figure_format = &#x27;svg&#x27;plt.figure(0, figsize=(16, 10))for i in range(1, 8): face = data[data[&#x27;emotion&#x27;] == i - 1].iloc[0] img, label = row2image_label(face) plt.subplot(2, 4, i) plt.imshow(img) plt.title(label)plt.show() 数据预处理数据预处理部分，主要完成了下面四个事情： 分割数据为3个部分: train, validation, test 将数据标签由字符串改为整数 调整图片大小为 48x48, 归一化图像 更改标签编码为one-hot, 例如类别3（Happy）对应为$[0,0,0,1,0,0,0]$ 1234567891011121314151617181920212223242526272829303132333435#分割数据为: train, validation, testdata_train = data[data[&#x27;Usage&#x27;] == &#x27;Training&#x27;].copy()data_val = data[data[&#x27;Usage&#x27;] == &#x27;PublicTest&#x27;].copy()data_test = data[data[&#x27;Usage&#x27;] == &#x27;PrivateTest&#x27;].copy()print(f&quot;train shape: &#123;data_train.shape&#125;&quot;)print(f&quot;validation shape: &#123;data_val.shape&#125;&quot;)print(f&quot;test shape: &#123;data_test.shape&#125;&quot;)# %%# 绘制train, val, test的条形图emotion_labels = [&#x27;Angry&#x27;, &#x27;Disgust&#x27;, &#x27;Fear&#x27;, &#x27;Happy&#x27;, &#x27;Sad&#x27;, &#x27;Surprise&#x27;, &#x27;Neutral&#x27;]def setup_axe(axe, df, title): df[&#x27;emotion&#x27;].value_counts().sort_index().plot(ax=axe, kind=&#x27;bar&#x27;, rot=0, color=[&#x27;r&#x27;, &#x27;g&#x27;, &#x27;b&#x27;, &#x27;r&#x27;, &#x27;g&#x27;, &#x27;b&#x27;, &#x27;r&#x27;]) axe.set_xticklabels(emotion_labels) axe.set_xlabel(&quot;Emotions&quot;) axe.set_ylabel(&quot;Number&quot;) axe.set_title(title) # 使用上述列表设置单个条形标签 for i in axe.patches: # get_x pulls left or right; get_height pushes up or down axe.text(i.get_x() - .05, i.get_height() + 120, str(round((i.get_height()), 2)), fontsize=14, color=&#x27;dimgrey&#x27;, rotation=0)%matplotlib inline%config InlineBackend.figure_format = &#x27;svg&#x27;fig, axes = plt.subplots(1, 3, figsize=(20, 8), sharey=&#x27;all&#x27;)setup_axe(axes[0], data_train, &#x27;Train&#x27;)setup_axe(axes[1], data_val, &#x27;Validation&#x27;)setup_axe(axes[2], data_test, &#x27;Test&#x27;)plt.show() 经过处理后的各个子数据集的样本分布情况如下图所示。 子数据集分布情况 1234567891011def CRNO(df, dataName): df[&#x27;pixels&#x27;] = df[&#x27;pixels&#x27;].apply(lambda pixel_sequence: [int(pixel) for pixel in pixel_sequence.split()]) data_X = np.array(df[&#x27;pixels&#x27;].tolist(), dtype=&#x27;float32&#x27;).reshape(-1, width, height, 1) / 255.0 data_Y = to_categorical(df[&#x27;emotion&#x27;], num_classes) print(dataName, f&quot;_X shape: &#123;data_X.shape&#125;, &quot;, dataName, f&quot;_Y shape: &#123;data_Y.shape&#125;&quot;) return data_X, data_Ytrain_X, train_Y = CRNO(data_train, &quot;train&quot;) #training dataval_X, val_Y = CRNO(data_val, &quot;val&quot;) #validation datatest_X, test_Y = CRNO(data_test, &quot;test&quot;) #test data 各子数据集的输入和预期输出的形状如下： Outputtrain _X shape: (28709, 48, 48, 1), train _Y shape: (28709, 7)val _X shape: (3589, 48, 48, 1), val _Y shape: (3589, 7)test _X shape: (3589, 48, 48, 1), test _Y shape: (3589, 7) 构建我们的神经网络我们的神经网络的整体结构已在前文中给出, 每个层的具体参数如下表所示。 具体代码如下所示，注意到代码中已经设置了SGD的具体优化参数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# ## 构建我们的CNN# # ### CNN 结构:# Conv Sages 1 --&gt; Conv Stages 2 --&gt; Conv Stages 3 --&gt; Conv Stages 4 --&gt; Flatten --&gt; Full Connection --&gt; Softmax Output Layer# # ### Conv Stages# Conv Block --&gt; Max Pooling# # ### Conv Block# Conv --&gt; BN --&gt; ReLU# %%model = Sequential()# ---------- Convolutional Stages 1 ----------# ***** Conv Block a *****model.add(Conv2D(64, kernel_size=(3, 3), input_shape=(width, height, 1), data_format=&#x27;channels_last&#x27;, padding=&#x27;same&#x27;))model.add(BatchNormalization())model.add(Activation(&#x27;relu&#x27;))# ***** Conv Block b *****model.add(Conv2D(64, kernel_size=(3, 3), padding=&#x27;same&#x27;))model.add(BatchNormalization())model.add(Activation(&#x27;relu&#x27;))# max poolingmodel.add(MaxPooling2D(pool_size=(2, 2)))# ---------- Convolutional Stages 2 ----------# ***** Conv Block a *****model.add(Conv2D(128, kernel_size=(3, 3), padding=&#x27;same&#x27;))model.add(BatchNormalization())model.add(Activation(&#x27;relu&#x27;))# ***** Conv Block b *****model.add(Conv2D(128, kernel_size=(3, 3), padding=&#x27;same&#x27;))model.add(BatchNormalization())model.add(Activation(&#x27;relu&#x27;))# max poolingmodel.add(MaxPooling2D(pool_size=(2, 2)))# ---------- Convolutional Stages 3 ----------# ***** Conv Block a *****model.add(Conv2D(256, kernel_size=(3, 3), padding=&#x27;same&#x27;))model.add(BatchNormalization())model.add(Activation(&#x27;relu&#x27;))# ***** Conv Block b *****model.add(Conv2D(256, kernel_size=(3, 3), padding=&#x27;same&#x27;))model.add(BatchNormalization())model.add(Activation(&#x27;relu&#x27;))# max poolingmodel.add(MaxPooling2D(pool_size=(2, 2)))# ---------- Convolutional Stages 4 ----------# ***** Conv Block a *****model.add(Conv2D(512, kernel_size=(3, 3), padding=&#x27;same&#x27;))model.add(BatchNormalization())model.add(Activation(&#x27;relu&#x27;))# ***** Conv Block b *****model.add(Conv2D(512, kernel_size=(3, 3), padding=&#x27;same&#x27;))model.add(BatchNormalization())model.add(Activation(&#x27;relu&#x27;))# max poolingmodel.add(MaxPooling2D(pool_size=(2, 2)))# Flattenmodel.add(Flatten())# Full connectionmodel.add(Dense(4096, activation=&#x27;relu&#x27;, kernel_regularizer=l2()))model.add(Dropout(rate_drop))model.add(Dense(4096, activation=&#x27;relu&#x27;, kernel_regularizer=l2()))model.add(Dropout(rate_drop))#output layermodel.add(Dense(num_classes, activation=&#x27;softmax&#x27;, kernel_regularizer=l2()))model.compile(loss=[&#x27;categorical_crossentropy&#x27;], optimizer=SGD(momentum=0.9, nesterov=True ,decay=1e-4), metrics=[&#x27;accuracy&#x27;])model.summary() 数据增强根据前文，使用Keras框架自带的ImageDataGenerator方法，编写如下代码。 12345678# 数据增强data_generator = ImageDataGenerator( zoom_range=0.2, width_shift_range=0.2, height_shift_range=0.2, rotation_range=10, featurewise_std_normalization=False, horizontal_flip=True)"},{"title":"系统设计","path":"/wiki/FER/system-desin.html","content":"数据预处理数据集分割为了训练FER2013数据集，我们参照ICML官方设计的训练（Training）、验证（Validation）、测试（Test）数据集的分割方法，即80%作为训练数据集，10%作为验证数据集，10%作为测试数据集。 数据增强为了能让我们的卷积神经网络对表情识别有更加可靠的自适应性，我们可以在神经网络的训练中使用数据增强（Data Augmentation）。基于批量（Batch）数据的实时训练方式，我们的数据增强方法如下表所示。 处理方式 参数设置 效果 1 Zoom ±20% 对图像做随机缩放 2 Width/Height Shift ±20% 水平/垂直平移 3 Rotation ±10% 随机旋转角度 4 Horizontal Flip 水平镜像 VGGNet 网络结构VGGNet是一种用于大规模图像处理和模式识别的经典卷积神经网络结构。我们的搭建的VGGNet变体如下图所示。 VGGNet 结构示意图 该网络由4个卷积级（Convolutional Stages）和3个全连接层（Fully Connected Layers）组成。每个卷积级包含两个卷积块（Convolutional Blocks）和一个最大池化层（Max Pooling）。卷积块由卷积层（Convolution）、ReLU激活函数和批标准化层（Batch Normalization）组成。批标准化能够加速神经网络的学习过程，减少内部协方差偏移，以及防止梯度消失或爆炸。前两个全连接层之后是ReLU激活函数。第三个全连接层用于最终分类，使用SoftMax激活函数。卷积级的作用是特征提取、降维和非线性。经过全连接层的训练，我们可以根据提取的特征对输入图像进行分类。 神经网络的优化方法基于Nesterov momentum的SGD方法我们回顾基本的mini-bacth SGD方法，其原理是，采用训练数据的一部分，生成批量样本（mini-batch），然后对批量样本，使用随机梯度下降法（SGD）更新权值（weights）和偏置（biases），如下面的公式所示。 其中， 就是学习速率，m是mini-batch的样本数量。 mini-bacth SGD的核心是对权值梯度和偏置的梯度，经过反向传播的方式进行更新。因此，我们也把基于SGD方法的神经网络称为BP神经网络。 进一步，我们使用动量（momentum）方法更好地完成对权值的更新。当使用SGD训练参数时，有时候会下降的非常慢，并且可能会陷入到局部最小值中。momentum的引入就是为了加快学习过程，特别是对于高曲率、小但一致的梯度，或者噪声比较大的梯度能够很好的加快学习过程。 我们引入速度变量，其中每一个对应变量。然后我们将上述公式中关于权值的梯度下降更新规则改成如下的公式。 其中, 是一个超参数，其值越大，则之前的梯度对现在的方向影响越大。 最后，Nesterov momentum是对momentum的改进，可以理解为Nesterov动量在标准动量方法中添加了一个校正因子。与momentum的唯一区别就是计算梯度的不同，Nesterov先用当前的速度v更新一遍参数，再用更新的临时参数计算梯度。即上述公式中的梯度计算先使用如下的公式。 学习速率监测器学习速率通常会影响神经网络的训练的效果，当评价指标不再提升时，我们应该降低学习速率，因为此时，较慢的学习速率能找到更精准的网络。 我们使用Reduce Learning Rate on Plateau（RLRP）策略：当评估标准停止提升时，降低一定的学习速率。当学习停止时，模型总是会受益于降低 2-10 倍的学习速率。我们检测某个数据并且当这个数据在一定“有耐心”的训练轮之后还没有进步，那么学习速率就会被降低。"},{"title":"系统测试","path":"/wiki/FER/system-test.html","content":"训练我们的神经网络设置训练参数如下： 1234567#初始化参数num_classes = 7width, height = 48, 48num_epochs = 300batch_size = 128num_features = 64rate_drop = 0.1 进行训练： 1234567891011es = EarlyStopping(monitor=&#x27;val_loss&#x27;, patience=10, mode=&#x27;min&#x27;, restore_best_weights=True)reduce_lr = ReduceLROnPlateau(monitor=&#x27;val_accuracy&#x27;, factor=0.75, patience=5, verbose=1)history = model.fit(data_generator.flow(train_X, train_Y, batch_size), # steps_per_epoch=len(train_X) / batch_size, batch_size=batch_size, epochs=num_epochs, verbose=2, callbacks=[es, reduce_lr], validation_data=(val_X, val_Y)) 注意到，在上述代码中，使用了两个策略监测我们的网络： 过拟合监测，如果没有更小的验证损失，则网络停止训练 学习速率监测，如果没有更好的验证精度，则降低学习速率 部分训练输出信息如下： Output2021-12-26 05:35:09.313687: I tensorflow&#x2F;compiler&#x2F;mlir&#x2F;mlir_graph_optimization_pass.cc:185] None of the MLIR Optimization Passes are enabled (registered 2)Epoch 1&#x2F;3002021-12-26 05:35:10.991111: I tensorflow&#x2F;stream_executor&#x2F;cuda&#x2F;cuda_dnn.cc:369] Loaded cuDNN version 8005225&#x2F;225 - 20s - loss: 2.0907 - accuracy: 0.2503 - val_loss: 1.9219 - val_accuracy: 0.2494Epoch 2&#x2F;300225&#x2F;225 - 12s - loss: 1.8205 - accuracy: 0.2714 - val_loss: 1.8866 - val_accuracy: 0.2611Epoch 3&#x2F;300225&#x2F;225 - 12s - loss: 1.6999 - accuracy: 0.3240 - val_loss: 1.8933 - val_accuracy: 0.3090……Epoch 00020: ReduceLROnPlateau reducing learning rate to 0.007499999832361937.……Epoch 00037: ReduceLROnPlateau reducing learning rate to 0.005624999874271452.……Epoch 00048: ReduceLROnPlateau reducing learning rate to 0.004218749818392098.Epoch 49&#x2F;300225&#x2F;225 - 13s - loss: 0.7174 - accuracy: 0.7382 - val_loss: 1.0229 - val_accuracy: 0.6559 我们观察到，训练过程中存在3次学习速率调整，最终在第49次迭代时提前终止训练。 可视化训练效果 代码如下： 12345678910111213141516171819%matplotlib inline%config InlineBackend.figure_format = &#x27;svg&#x27;fig, axes = plt.subplots(1, 2, figsize=(18, 6))# 绘制训练和验证精度曲线axes[0].plot(history.history[&#x27;accuracy&#x27;])axes[0].plot(history.history[&#x27;val_accuracy&#x27;])axes[0].set_title(&#x27;Model accuracy&#x27;)axes[0].set_ylabel(&#x27;Accuracy&#x27;)axes[0].set_xlabel(&#x27;Epoch&#x27;)axes[0].legend([&#x27;Train&#x27;, &#x27;Validation&#x27;], loc=&#x27;upper left&#x27;)# 绘制训练和验证损失曲线axes[1].plot(history.history[&#x27;loss&#x27;])axes[1].plot(history.history[&#x27;val_loss&#x27;])axes[1].set_title(&#x27;Model loss&#x27;)axes[1].set_ylabel(&#x27;Loss&#x27;)axes[1].set_xlabel(&#x27;Epoch&#x27;)axes[1].legend([&#x27;Train&#x27;, &#x27;Validation&#x27;], loc=&#x27;upper left&#x27;)plt.show() 通过观察曲线，我们可以得知神经网络后期存在轻微的过拟合现象。 评估测试效果我们对测试数据集，进行评估分析，代码如下： 123test_true = np.argmax(test_Y, axis=1)test_pred = np.argmax(model.predict(test_X), axis=1)print(&quot;CNN Model Accuracy on test set: &#123;:.4f&#125;&quot;.format(accuracy_score(test_true, test_pred))) 输出信息如下： OutputCNN Model Accuracy on test set: 0.6704 最终，我们的VGGNet网络，对各个数据集的准确率，如下表所示。 Accuracy Train 73.28% Validation 65.59% Test 67.04% 使用混淆矩阵进行分析绘制混淆矩阵，以分析表情之间是否会相互混淆，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859fusion_matrix(y_true, y_pred, classes, normalize=False, title=None, cmap=plt.cm.Blues): &quot;&quot;&quot; 此函数打印和绘制混淆矩阵 可以通过设置“normalize=True”来应用规范化。 &quot;&quot;&quot; if not title: if normalize: title = &#x27;Normalized confusion matrix&#x27; else: title = &#x27;Confusion matrix, without normalization&#x27; # 计算混淆矩阵 cm = confusion_matrix(y_true, y_pred) # 仅使用数据中显示的标签 classes = classes if normalize: cm = cm.astype(&#x27;float&#x27;) / cm.sum(axis=1)[:, np.newaxis] #print(&quot;Normalized confusion matrix&quot;) #else: #print(&#x27;Confusion matrix, without normalization&#x27;) #print(cm) fig, ax = plt.subplots(figsize=(12, 6)) im = ax.imshow(cm, interpolation=&#x27;nearest&#x27;, cmap=cmap) ax.figure.colorbar(im, ax=ax) # 显示所有的标记... ax.set(xticks=np.arange(cm.shape[1]), yticks=np.arange(cm.shape[0]), # ... 用相应的列表条目标记它们 xticklabels=classes, yticklabels=classes, title=title, ylabel=&#x27;True label&#x27;, xlabel=&#x27;Predicted label&#x27;) # 旋转x轴标签并设置其对齐方式。 plt.setp(ax.get_xticklabels(), rotation=45, ha=&quot;right&quot;, rotation_mode=&quot;anchor&quot;) # 在数据维度上循环并创建文本批注 fmt = &#x27;.2f&#x27; if normalize else &#x27;d&#x27; thresh = cm.max() / 2. for i in range(cm.shape[0]): for j in range(cm.shape[1]): ax.text(j, i, format(cm[i, j], fmt), ha=&quot;center&quot;, va=&quot;center&quot;, color=&quot;white&quot; if cm[i, j] &gt; thresh else &quot;black&quot;) fig.tight_layout() return ax# %%# 绘制归一化混淆矩阵%matplotlib inline%config InlineBackend.figure_format = &#x27;svg&#x27;plot_confusion_matrix(test_true, test_pred, classes=emotion_labels, normalize=True, title=&#x27;Normalized confusion matrix&#x27;)plt.show() 输出的混淆矩阵如下图所示。通过分析混淆矩阵，可知：Disgust比较容易和其他表情混淆，这是由于Disgust的样本数本身就很少。 实时人脸表情识别将已经训练好的模型存入本地，使用摄像头实时捕捉人脸，并识别出相应的表情。我们的思路是，从捕获的图像中，先使用人脸检测器，检测出人脸区域，然后将该区域实施灰度化，并将图片大小缩放至$48\\times 48$，最后送入我们的模型，进行预测，得到相应的表情输出。相应的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import cv2 as cvimport numpy as npfrom keras import modelsmodel = models.load_model(&#x27;./FER_Model.h5&#x27;)emotion_map = &#123;0: &#x27;Angry&#x27;, 1: &#x27;Disgust&#x27;, 2: &#x27;Fear&#x27;, 3: &#x27;Happy&#x27;, 4: &#x27;Sad&#x27;, 5: &#x27;Surprise&#x27;, 6: &#x27;Neutral&#x27;&#125;cap = cv.VideoCapture(0)if not cap.isOpened(): print(&quot;Can not open camera!&quot;) exit()while True: # 逐帧捕获 ret, frame = cap.read() # 转换成灰度图像 gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) classifier = cv.CascadeClassifier(&quot;./haarcascade_frontalface_default.xml&quot;) faceRects = classifier.detectMultiScale(gray, scaleFactor=1.2, minNeighbors=3, minSize=(32, 32)) color = (0, 0, 255) if len(faceRects): # 大于0则检测到人脸 for faceRect in faceRects: # 单独框出每一张人脸 x, y, w, h = faceRect # 框出人脸 cv.rectangle(frame, (x, y), (x + h, y + w), color, 2) # 获取人脸源 src = gray[y:y + w, x:x + h] # 缩放至48*48 img = cv.resize(src, (48, 48)) # 归一化 img = img / 255. # 扩展维度 x = np.expand_dims(img, axis=0) x = np.array(x, dtype=&#x27;float32&#x27;).reshape(-1, 48, 48, 1) # 预测输出 y = model.predict(x) output_class = np.argmax(y[0]) cv.putText(frame, emotion_map[output_class], (200, 100), cv.FONT_HERSHEY_COMPLEX, 2.0, (0, 0, 250), 5) cv.imshow(&quot;frame&quot;, frame) if cv.waitKey(1) == ord(&#x27;q&#x27;): breakcap.release()cv.destroyAllWindows() 上述代码中，haarcascade_frontalface_default.xml是由OpenCV提供的人脸检测器。 识别效果样例如下图所示。"}]